---
layout: post
title:  "Union-Find를 공부하며"
date:   2016-11-20 11:57:00 +0700
categories: [알고리즘]
---
## 목차
---
* 목차
{:toc}

## 개요
---
알고리즘 과제를 하다가 Union-Find라는 자료구조를 사용해야해서 공부하는 김에 작성한다.

>**Union-Find란?** : 
Union-Find란 Disjoint set을 표현할 때 사용하는 독특한 형태의 자료구조이다.

**Union-Find 지원연산**

- 초기화 : N개의 원소가 각각의 집합에 포함되어 있도록 초기화 한다.
- Union(합치기)연산 : 두 원소 a,b가 주어질 때, 이들이 속한 두 집합을 하나로 합친다.
- Find(찾기)연산 : 어떤 원소 a가 주어질 때, 이 원소가 속한 집합을 반환한다.

## Union-Find의 구현
---
Union-Find의 실제 구현은 주로 트리구조를 이용하는데, 왜 배열을 이용하지 않는지, 트리를 사용했을 때의 장점이 무엇인지 알아보자.

### 배열로 표현하기
> Array[i] = i 번 원소가 속하는 집합의 번호

### Union-Find 지원연산
- 초기화 : Array[i] = i 와 같이 각자 다른 집합 번호로 초기화 해준다.
- Union(합치기)연산 : 두 집합을 합치기 위해 배열의 모든 원소를 순회 하면서 하나의 집합 번호를 나머지 한개의 집합 번호로 교체한다.O(N)
- Find(찾기)연산 : 한번만에 원소가 속하는 집합번호를 알 수 있다. O(1)

### 수행속도

- Union 연산 : O(N)
- FInd 연산 : O(1)

### 트리로 표현하기

트리로 구현하면 배열로 구현했을 때의 문제점인 Union연산의 속도를 빠르게할 수 있다.

#### 트리 이해

##### Base 1

한 집합에 속하는 원소들을 하나의 트리로 묶어주기때문에, 자료구조는 **트리들의 집합**으로 표현된다.

##### Base 2

트리 구조에는 트리의 대표노드라고도 볼 수 있는 루트노드가 존재하므로, 각 원소가 속하는 집합 번호를 바로 이 루트노드의 원소로 정한다.

##### Base 3

Union 연산을 수행하기 위해서는 두 우너소가 같은 집합에 속하는지를 먼저 확인한 후, 다른 집합에 속할 때만 합쳐야 한다.
같은 집합에 속한다는 뜻은, 같은 루트노드를 가진다는 말과 대앙되므로 어떤 원소의 루트 노드를 찾는 Find연산을 지원해야한다.

##### Base 4

이러한 Find 연산을 지원하기 위해서 모든 자식 노드가 부모에대한 포인터 정보를 가지고있도록 한다. 
이러한 설정은 가진 정보를 바탕으로 포인터를 따라가 결과적으로 최종부모인 루트 노드가 무엇인지 찾을 수 있게 된다.
단, 부모노드에서 자식노드로 내려가는 일은 발생하지 않기 때문에 부모가 자식에 대한 포인터 정보를 가질 필요는 없다.

#### Union-Find 지원연산
- 초기화 : 
- Union(합치기)연산 : 
- Find(찾기)연산 : 

### 수행속도
- Union 연산 : O(logN)
- Find 연산 : O(logN)
> logN은 Tree의 높이다.